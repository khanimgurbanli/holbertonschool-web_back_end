// src/index.ts
import { Keyv } from "keyv";
import { Hookified } from "hookified";

// src/shorthand-time.ts
var shorthandToMilliseconds = (shorthand) => {
  let milliseconds;
  if (shorthand === void 0) {
    return void 0;
  }
  if (typeof shorthand === "number") {
    milliseconds = shorthand;
  } else if (typeof shorthand === "string") {
    shorthand = shorthand.trim();
    if (Number.isNaN(Number(shorthand))) {
      const match = /^([\d.]+)\s*(ms|s|m|h|hr|d)$/i.exec(shorthand);
      if (!match) {
        throw new Error(
          `Unsupported time format: "${shorthand}". Use 'ms', 's', 'm', 'h', 'hr', or 'd'.`
        );
      }
      const [, value, unit] = match;
      const numericValue = Number.parseFloat(value);
      const unitLower = unit.toLowerCase();
      switch (unitLower) {
        case "ms": {
          milliseconds = numericValue;
          break;
        }
        case "s": {
          milliseconds = numericValue * 1e3;
          break;
        }
        case "m": {
          milliseconds = numericValue * 1e3 * 60;
          break;
        }
        case "h": {
          milliseconds = numericValue * 1e3 * 60 * 60;
          break;
        }
        case "hr": {
          milliseconds = numericValue * 1e3 * 60 * 60;
          break;
        }
        case "d": {
          milliseconds = numericValue * 1e3 * 60 * 60 * 24;
          break;
        }
        /* c8 ignore next 3 */
        default: {
          milliseconds = Number(shorthand);
        }
      }
    } else {
      milliseconds = Number(shorthand);
    }
  } else {
    throw new TypeError("Time must be a string or a number.");
  }
  return milliseconds;
};
var shorthandToTime = (shorthand, fromDate) => {
  fromDate ||= /* @__PURE__ */ new Date();
  const milliseconds = shorthandToMilliseconds(shorthand);
  if (milliseconds === void 0) {
    return fromDate.getTime();
  }
  return fromDate.getTime() + milliseconds;
};

// src/wrap.ts
function wrapSync(function_, options) {
  const { ttl, key, cache } = options;
  return function(...arguments_) {
    const cacheKey = key ?? cache.hash(arguments_);
    let value = cache.get(cacheKey);
    if (value === void 0) {
      value = function_(...arguments_);
      cache.set(cacheKey, value, ttl);
    }
    return value;
  };
}
function wrap(function_, options) {
  const { ttl, key, cache } = options;
  return async function(...arguments_) {
    const cacheKey = key ?? cache.hash(arguments_);
    let value = await cache.get(cacheKey);
    if (value === void 0) {
      value = await function_(...arguments_);
      await cache.set(cacheKey, value, ttl);
    }
    return value;
  };
}

// src/memory-lru.ts
var ListNode = class {
  // eslint-disable-next-line @typescript-eslint/parameter-properties
  value;
  prev = void 0;
  next = void 0;
  constructor(value) {
    this.value = value;
  }
};
var DoublyLinkedList = class {
  head = void 0;
  tail = void 0;
  nodesMap = /* @__PURE__ */ new Map();
  // Add a new node to the front (most recently used)
  addToFront(value) {
    const newNode = new ListNode(value);
    if (this.head) {
      newNode.next = this.head;
      this.head.prev = newNode;
      this.head = newNode;
    } else {
      this.head = this.tail = newNode;
    }
    this.nodesMap.set(value, newNode);
  }
  // Move an existing node to the front (most recently used)
  moveToFront(value) {
    const node = this.nodesMap.get(value);
    if (!node || this.head === node) {
      return;
    }
    if (node.prev) {
      node.prev.next = node.next;
    }
    if (node.next) {
      node.next.prev = node.prev;
    }
    if (node === this.tail) {
      this.tail = node.prev;
    }
    node.prev = void 0;
    node.next = this.head;
    if (this.head) {
      this.head.prev = node;
    }
    this.head = node;
    this.tail ||= node;
  }
  // Get the oldest node (tail)
  getOldest() {
    return this.tail ? this.tail.value : void 0;
  }
  // Remove the oldest node (tail)
  removeOldest() {
    if (!this.tail) {
      return void 0;
    }
    const oldValue = this.tail.value;
    if (this.tail.prev) {
      this.tail = this.tail.prev;
      this.tail.next = void 0;
    } else {
      this.head = this.tail = void 0;
    }
    this.nodesMap.delete(oldValue);
    return oldValue;
  }
  get size() {
    return this.nodesMap.size;
  }
};

// src/hash.ts
import * as crypto from "node:crypto";
function hash(object, algorithm = "sha256") {
  const objectString = JSON.stringify(object);
  if (!crypto.getHashes().includes(algorithm)) {
    throw new Error(`Unsupported hash algorithm: '${algorithm}'`);
  }
  const hasher = crypto.createHash(algorithm);
  hasher.update(objectString);
  return hasher.digest("hex");
}

// src/memory.ts
var CacheableMemory = class {
  _hashCache = /* @__PURE__ */ new Map();
  _hash0 = /* @__PURE__ */ new Map();
  _hash1 = /* @__PURE__ */ new Map();
  _hash2 = /* @__PURE__ */ new Map();
  _hash3 = /* @__PURE__ */ new Map();
  _hash4 = /* @__PURE__ */ new Map();
  _hash5 = /* @__PURE__ */ new Map();
  _hash6 = /* @__PURE__ */ new Map();
  _hash7 = /* @__PURE__ */ new Map();
  _hash8 = /* @__PURE__ */ new Map();
  _hash9 = /* @__PURE__ */ new Map();
  _lru = new DoublyLinkedList();
  _ttl;
  // Turned off by default
  _useClone = true;
  // Turned on by default
  _lruSize = 0;
  // Turned off by default
  _checkInterval = 0;
  // Turned off by default
  _interval = 0;
  // Turned off by default
  constructor(options) {
    if (options?.ttl) {
      this.setTtl(options.ttl);
    }
    if (options?.useClone !== void 0) {
      this._useClone = options.useClone;
    }
    if (options?.lruSize) {
      this._lruSize = options.lruSize;
    }
    if (options?.checkInterval) {
      this._checkInterval = options.checkInterval;
    }
    this.startIntervalCheck();
  }
  get ttl() {
    return this._ttl;
  }
  set ttl(value) {
    this.setTtl(value);
  }
  get useClone() {
    return this._useClone;
  }
  set useClone(value) {
    this._useClone = value;
  }
  get lruSize() {
    return this._lruSize;
  }
  set lruSize(value) {
    this._lruSize = value;
    this.lruResize();
  }
  get checkInterval() {
    return this._checkInterval;
  }
  set checkInterval(value) {
    this._checkInterval = value;
  }
  get size() {
    return this._hash0.size + this._hash1.size + this._hash2.size + this._hash3.size + this._hash4.size + this._hash5.size + this._hash6.size + this._hash7.size + this._hash8.size + this._hash9.size;
  }
  get keys() {
    return this.concatStores().keys();
  }
  get items() {
    return this.concatStores().values();
  }
  get(key) {
    const store = this.getStore(key);
    const item = store.get(key);
    if (!item) {
      return void 0;
    }
    if (item.expires && item.expires && Date.now() > item.expires) {
      store.delete(key);
      return void 0;
    }
    this.lruMoveToFront(key);
    if (!this._useClone) {
      return item.value;
    }
    return this.clone(item.value);
  }
  getMany(keys) {
    const result = new Array();
    for (const key of keys) {
      result.push(this.get(key));
    }
    return result;
  }
  getRaw(key) {
    const store = this.getStore(key);
    const item = store.get(key);
    if (!item) {
      return void 0;
    }
    if (item.expires && item.expires && Date.now() > item.expires) {
      store.delete(key);
      return void 0;
    }
    this.lruMoveToFront(key);
    return item;
  }
  getManyRaw(keys) {
    const result = new Array();
    for (const key of keys) {
      result.push(this.getRaw(key));
    }
    return result;
  }
  set(key, value, ttl) {
    const store = this.getStore(key);
    let expires;
    if (ttl !== void 0 || this._ttl !== void 0) {
      const finalTtl = shorthandToTime(ttl ?? this._ttl);
      if (finalTtl !== void 0) {
        expires = finalTtl;
      }
    }
    if (this._lruSize > 0) {
      if (store.has(key)) {
        this.lruMoveToFront(key);
      } else {
        this.lruAddToFront(key);
        if (this._lru.size > this._lruSize) {
          const oldestKey = this._lru.getOldest();
          if (oldestKey) {
            this._lru.removeOldest();
            this.delete(oldestKey);
          }
        }
      }
    }
    store.set(key, {
      key,
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      value,
      expires
    });
  }
  setMany(items) {
    for (const item of items) {
      this.set(item.key, item.value, item.ttl);
    }
  }
  has(key) {
    const item = this.get(key);
    return Boolean(item);
  }
  take(key) {
    const item = this.get(key);
    if (!item) {
      return void 0;
    }
    this.delete(key);
    return item;
  }
  takeMany(keys) {
    const result = new Array();
    for (const key of keys) {
      result.push(this.take(key));
    }
    return result;
  }
  delete(key) {
    const store = this.getStore(key);
    store.delete(key);
  }
  deleteMany(keys) {
    for (const key of keys) {
      this.delete(key);
    }
  }
  clear() {
    this._hash0.clear();
    this._hash1.clear();
    this._hash2.clear();
    this._hash3.clear();
    this._hash4.clear();
    this._hash5.clear();
    this._hash6.clear();
    this._hash7.clear();
    this._hash8.clear();
    this._hash9.clear();
    this._hashCache.clear();
  }
  hashKey(key) {
    const cacheHashNumber = this._hashCache.get(key);
    if (cacheHashNumber) {
      return cacheHashNumber;
    }
    let hash2 = 0;
    const primeMultiplier = 31;
    for (let i = 0; i < key.length; i++) {
      hash2 = hash2 * primeMultiplier + key.charCodeAt(i);
    }
    const result = Math.abs(hash2) % 10;
    this._hashCache.set(key, result);
    return result;
  }
  getStore(key) {
    const hashKey = this.hashKey(key);
    switch (hashKey) {
      case 1: {
        return this._hash1;
      }
      case 2: {
        return this._hash2;
      }
      case 3: {
        return this._hash3;
      }
      case 4: {
        return this._hash4;
      }
      case 5: {
        return this._hash5;
      }
      case 6: {
        return this._hash6;
      }
      case 7: {
        return this._hash7;
      }
      case 8: {
        return this._hash8;
      }
      case 9: {
        return this._hash9;
      }
      default: {
        return this._hash0;
      }
    }
  }
  clone(value) {
    if (this.isPrimitive(value)) {
      return value;
    }
    return structuredClone(value);
  }
  lruAddToFront(key) {
    if (this._lruSize === 0) {
      return;
    }
    this._lru.addToFront(key);
  }
  lruMoveToFront(key) {
    if (this._lruSize === 0) {
      return;
    }
    this._lru.moveToFront(key);
  }
  lruResize() {
    if (this._lruSize === 0) {
      return;
    }
    while (this._lru.size > this._lruSize) {
      const oldestKey = this._lru.getOldest();
      if (oldestKey) {
        this._lru.removeOldest();
        this.delete(oldestKey);
      }
    }
  }
  checkExpiration() {
    const stores = this.concatStores();
    for (const item of stores.values()) {
      if (item.expires && Date.now() > item.expires) {
        this.delete(item.key);
      }
    }
  }
  startIntervalCheck() {
    if (this._checkInterval > 0) {
      this._interval = setInterval(() => {
        this.checkExpiration();
      }, this._checkInterval);
    }
  }
  stopIntervalCheck() {
    if (this._interval) {
      clearInterval(this._interval);
    }
    this._interval = 0;
    this._checkInterval = 0;
  }
  hash(object, algorithm = "sha256") {
    return hash(object, algorithm);
  }
  wrap(function_, options = {}) {
    const wrapOptions = {
      ttl: options.ttl,
      key: options.key,
      cache: this
    };
    return wrapSync(function_, wrapOptions);
  }
  isPrimitive(value) {
    const result = false;
    if (value === null || value === void 0) {
      return true;
    }
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      return true;
    }
    return result;
  }
  concatStores() {
    const result = new Map([...this._hash0, ...this._hash1, ...this._hash2, ...this._hash3, ...this._hash4, ...this._hash5, ...this._hash6, ...this._hash7, ...this._hash8, ...this._hash9]);
    return result;
  }
  setTtl(ttl) {
    if (typeof ttl === "string" || ttl === void 0) {
      this._ttl = ttl;
    } else if (ttl > 0) {
      this._ttl = ttl;
    } else {
      this._ttl = void 0;
    }
  }
};

// src/keyv-memory.ts
var KeyvCacheableMemory = class {
  opts = {
    ttl: 0,
    useClone: true,
    lruSize: 0,
    checkInterval: 0
  };
  namespace;
  _cache = new CacheableMemory();
  constructor(options) {
    if (options) {
      this.opts = options;
      this._cache = new CacheableMemory(options);
    }
  }
  async get(key) {
    const result = this._cache.get(key);
    if (result) {
      return result;
    }
    return void 0;
  }
  async getMany(keys) {
    const result = this._cache.getMany(keys);
    return result;
  }
  async set(key, value, ttl) {
    this._cache.set(key, value, ttl);
  }
  async setMany(values) {
    this._cache.setMany(values);
  }
  async delete(key) {
    this._cache.delete(key);
    return true;
  }
  async deleteMany(key) {
    this._cache.deleteMany(key);
    return true;
  }
  async clear() {
    this._cache.clear();
  }
  async has(key) {
    return this._cache.has(key);
  }
  on(event, listener) {
    return this;
  }
};

// src/stats.ts
var CacheableStats = class {
  _hits = 0;
  _misses = 0;
  _gets = 0;
  _sets = 0;
  _deletes = 0;
  _clears = 0;
  _vsize = 0;
  _ksize = 0;
  _count = 0;
  _enabled = false;
  constructor(options) {
    if (options?.enabled) {
      this._enabled = options.enabled;
    }
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    this._enabled = enabled;
  }
  get hits() {
    return this._hits;
  }
  get misses() {
    return this._misses;
  }
  get gets() {
    return this._gets;
  }
  get sets() {
    return this._sets;
  }
  get deletes() {
    return this._deletes;
  }
  get clears() {
    return this._clears;
  }
  get vsize() {
    return this._vsize;
  }
  get ksize() {
    return this._ksize;
  }
  get count() {
    return this._count;
  }
  incrementHits() {
    if (!this._enabled) {
      return;
    }
    this._hits++;
  }
  incrementMisses() {
    if (!this._enabled) {
      return;
    }
    this._misses++;
  }
  incrementGets() {
    if (!this._enabled) {
      return;
    }
    this._gets++;
  }
  incrementSets() {
    if (!this._enabled) {
      return;
    }
    this._sets++;
  }
  incrementDeletes() {
    if (!this._enabled) {
      return;
    }
    this._deletes++;
  }
  incrementClears() {
    if (!this._enabled) {
      return;
    }
    this._clears++;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  incrementVSize(value) {
    if (!this._enabled) {
      return;
    }
    this._vsize += this.roughSizeOfObject(value);
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  decreaseVSize(value) {
    if (!this._enabled) {
      return;
    }
    this._vsize -= this.roughSizeOfObject(value);
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  incrementKSize(key) {
    if (!this._enabled) {
      return;
    }
    this._ksize += this.roughSizeOfString(key);
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  decreaseKSize(key) {
    if (!this._enabled) {
      return;
    }
    this._ksize -= this.roughSizeOfString(key);
  }
  incrementCount() {
    if (!this._enabled) {
      return;
    }
    this._count++;
  }
  decreaseCount() {
    if (!this._enabled) {
      return;
    }
    this._count--;
  }
  setCount(count) {
    if (!this._enabled) {
      return;
    }
    this._count = count;
  }
  roughSizeOfString(value) {
    return value.length * 2;
  }
  roughSizeOfObject(object) {
    const objectList = [];
    const stack = [object];
    let bytes = 0;
    while (stack.length > 0) {
      const value = stack.pop();
      if (typeof value === "boolean") {
        bytes += 4;
      } else if (typeof value === "string") {
        bytes += value.length * 2;
      } else if (typeof value === "number") {
        bytes += 8;
      } else if (typeof value === "object" && value !== null && !objectList.includes(value)) {
        objectList.push(value);
        for (const key in value) {
          bytes += key.length * 2;
          stack.push(value[key]);
        }
      }
    }
    return bytes;
  }
  reset() {
    this._hits = 0;
    this._misses = 0;
    this._gets = 0;
    this._sets = 0;
    this._deletes = 0;
    this._clears = 0;
    this._vsize = 0;
    this._ksize = 0;
    this._count = 0;
  }
  resetStoreValues() {
    this._vsize = 0;
    this._ksize = 0;
    this._count = 0;
  }
};

// src/index.ts
import {
  KeyvHooks,
  Keyv as Keyv2
} from "keyv";
var CacheableHooks = /* @__PURE__ */ ((CacheableHooks2) => {
  CacheableHooks2["BEFORE_SET"] = "BEFORE_SET";
  CacheableHooks2["AFTER_SET"] = "AFTER_SET";
  CacheableHooks2["BEFORE_SET_MANY"] = "BEFORE_SET_MANY";
  CacheableHooks2["AFTER_SET_MANY"] = "AFTER_SET_MANY";
  CacheableHooks2["BEFORE_GET"] = "BEFORE_GET";
  CacheableHooks2["AFTER_GET"] = "AFTER_GET";
  CacheableHooks2["BEFORE_GET_MANY"] = "BEFORE_GET_MANY";
  CacheableHooks2["AFTER_GET_MANY"] = "AFTER_GET_MANY";
  return CacheableHooks2;
})(CacheableHooks || {});
var CacheableEvents = /* @__PURE__ */ ((CacheableEvents2) => {
  CacheableEvents2["ERROR"] = "error";
  return CacheableEvents2;
})(CacheableEvents || {});
var Cacheable = class extends Hookified {
  _primary = new Keyv({ store: new KeyvCacheableMemory() });
  _secondary;
  _nonBlocking = false;
  _ttl;
  _stats = new CacheableStats({ enabled: false });
  constructor(options) {
    super();
    if (options?.primary) {
      this.setPrimary(options.primary);
    }
    if (options?.secondary) {
      this.setSecondary(options.secondary);
    }
    if (options?.nonBlocking) {
      this._nonBlocking = options.nonBlocking;
    }
    if (options?.stats) {
      this._stats.enabled = options.stats;
    }
    if (options?.ttl) {
      this.setTtl(options.ttl);
    }
  }
  get stats() {
    return this._stats;
  }
  get primary() {
    return this._primary;
  }
  set primary(primary) {
    this._primary = primary;
  }
  get secondary() {
    return this._secondary;
  }
  set secondary(secondary) {
    this._secondary = secondary;
  }
  get nonBlocking() {
    return this._nonBlocking;
  }
  set nonBlocking(nonBlocking) {
    this._nonBlocking = nonBlocking;
  }
  get ttl() {
    return this._ttl;
  }
  set ttl(ttl) {
    this.setTtl(ttl);
  }
  setPrimary(primary) {
    this._primary = primary instanceof Keyv ? primary : new Keyv(primary);
  }
  setSecondary(secondary) {
    this._secondary = secondary instanceof Keyv ? secondary : new Keyv(secondary);
  }
  async get(key) {
    let result;
    try {
      await this.hook("BEFORE_GET" /* BEFORE_GET */, key);
      result = await this._primary.get(key);
      if (!result && this._secondary) {
        result = await this._secondary.get(key);
        if (result) {
          const finalTtl = shorthandToMilliseconds(this._ttl);
          await this._primary.set(key, result, finalTtl);
        }
      }
      await this.hook("AFTER_GET" /* AFTER_GET */, { key, result });
    } catch (error) {
      this.emit("error" /* ERROR */, error);
    }
    if (this.stats.enabled) {
      if (result) {
        this._stats.incrementHits();
      } else {
        this._stats.incrementMisses();
      }
      this.stats.incrementGets();
    }
    return result;
  }
  async getMany(keys) {
    let result = [];
    try {
      await this.hook("BEFORE_GET_MANY" /* BEFORE_GET_MANY */, keys);
      result = await this._primary.get(keys);
      if (this._secondary) {
        const missingKeys = [];
        for (const [i, key] of keys.entries()) {
          if (!result[i]) {
            missingKeys.push(key);
          }
        }
        const secondaryResult = await this._secondary.get(missingKeys);
        for (const [i, key] of keys.entries()) {
          if (!result[i] && secondaryResult[i]) {
            result[i] = secondaryResult[i];
            const finalTtl = shorthandToMilliseconds(this._ttl);
            await this._primary.set(key, secondaryResult[i], finalTtl);
          }
        }
      }
      await this.hook("AFTER_GET_MANY" /* AFTER_GET_MANY */, { keys, result });
    } catch (error) {
      this.emit("error" /* ERROR */, error);
    }
    if (this.stats.enabled) {
      for (const item of result) {
        if (item) {
          this._stats.incrementHits();
        } else {
          this._stats.incrementMisses();
        }
      }
      this.stats.incrementGets();
    }
    return result;
  }
  async set(key, value, ttl) {
    let result = false;
    const finalTtl = shorthandToMilliseconds(ttl ?? this._ttl);
    try {
      const item = { key, value, ttl: finalTtl };
      await this.hook("BEFORE_SET" /* BEFORE_SET */, item);
      const promises = [];
      promises.push(this._primary.set(item.key, item.value, item.ttl));
      if (this._secondary) {
        promises.push(this._secondary.set(item.key, item.value, item.ttl));
      }
      if (this._nonBlocking) {
        result = await Promise.race(promises);
      } else {
        const results = await Promise.all(promises);
        result = results[0];
      }
      await this.hook("AFTER_SET" /* AFTER_SET */, item);
    } catch (error) {
      this.emit("error" /* ERROR */, error);
    }
    if (this.stats.enabled) {
      this.stats.incrementKSize(key);
      this.stats.incrementCount();
      this.stats.incrementVSize(value);
      this.stats.incrementSets();
    }
    return result;
  }
  async setMany(items) {
    let result = false;
    try {
      await this.hook("BEFORE_SET_MANY" /* BEFORE_SET_MANY */, items);
      result = await this.setManyKeyv(this._primary, items);
      if (this._secondary) {
        if (this._nonBlocking) {
          this.setManyKeyv(this._secondary, items);
        } else {
          await this.setManyKeyv(this._secondary, items);
        }
      }
      await this.hook("AFTER_SET_MANY" /* AFTER_SET_MANY */, items);
    } catch (error) {
      this.emit("error" /* ERROR */, error);
    }
    if (this.stats.enabled) {
      for (const item of items) {
        this.stats.incrementKSize(item.key);
        this.stats.incrementCount();
        this.stats.incrementVSize(item.value);
      }
    }
    return result;
  }
  async take(key) {
    const result = await this.get(key);
    await this.delete(key);
    return result;
  }
  async takeMany(keys) {
    const result = await this.getMany(keys);
    await this.deleteMany(keys);
    return result;
  }
  async has(key) {
    const promises = [];
    promises.push(this._primary.has(key));
    if (this._secondary) {
      promises.push(this._secondary.has(key));
    }
    const resultAll = await Promise.all(promises);
    for (const result of resultAll) {
      if (result) {
        return true;
      }
    }
    return false;
  }
  async hasMany(keys) {
    const result = await this.hasManyKeyv(this._primary, keys);
    const missingKeys = [];
    for (const [i, key] of keys.entries()) {
      if (!result[i] && this._secondary) {
        missingKeys.push(key);
      }
    }
    if (missingKeys.length > 0 && this._secondary) {
      const secondary = await this.hasManyKeyv(this._secondary, keys);
      for (const [i, key] of keys.entries()) {
        if (!result[i] && secondary[i]) {
          result[i] = secondary[i];
        }
      }
    }
    return result;
  }
  async delete(key) {
    let result = false;
    const promises = [];
    if (this.stats.enabled) {
      const statResult = await this._primary.get(key);
      if (statResult) {
        this.stats.decreaseKSize(key);
        this.stats.decreaseVSize(statResult);
        this.stats.decreaseCount();
        this.stats.incrementDeletes();
      }
    }
    promises.push(this._primary.delete(key));
    if (this._secondary) {
      promises.push(this._secondary.delete(key));
    }
    if (this.nonBlocking) {
      result = await Promise.race(promises);
    } else {
      const resultAll = await Promise.all(promises);
      result = resultAll[0];
    }
    return result;
  }
  async deleteMany(keys) {
    if (this.stats.enabled) {
      const statResult = await this._primary.get(keys);
      for (const key of keys) {
        this.stats.decreaseKSize(key);
        this.stats.decreaseVSize(statResult);
        this.stats.decreaseCount();
        this.stats.incrementDeletes();
      }
    }
    const result = await this.deleteManyKeyv(this._primary, keys);
    if (this._secondary) {
      if (this._nonBlocking) {
        this.deleteManyKeyv(this._secondary, keys);
      } else {
        await this.deleteManyKeyv(this._secondary, keys);
      }
    }
    return result;
  }
  async clear() {
    const promises = [];
    promises.push(this._primary.clear());
    if (this._secondary) {
      promises.push(this._secondary.clear());
    }
    await (this._nonBlocking ? Promise.race(promises) : Promise.all(promises));
    if (this.stats.enabled) {
      this._stats.resetStoreValues();
      this._stats.incrementClears();
    }
  }
  async disconnect() {
    const promises = [];
    promises.push(this._primary.disconnect());
    if (this._secondary) {
      promises.push(this._secondary.disconnect());
    }
    await (this._nonBlocking ? Promise.race(promises) : Promise.all(promises));
  }
  wrap(function_, options = {}) {
    const wrapOptions = {
      ttl: options.ttl,
      key: options.key,
      cache: this
    };
    return wrap(function_, wrapOptions);
  }
  hash(object, algorithm = "sha256") {
    return hash(object, algorithm);
  }
  async deleteManyKeyv(keyv, keys) {
    const promises = [];
    for (const key of keys) {
      promises.push(keyv.delete(key));
    }
    await Promise.all(promises);
    return true;
  }
  async setManyKeyv(keyv, items) {
    const promises = [];
    for (const item of items) {
      const finalTtl = shorthandToMilliseconds(item.ttl ?? this._ttl);
      promises.push(keyv.set(item.key, item.value, finalTtl));
    }
    await Promise.all(promises);
    return true;
  }
  async hasManyKeyv(keyv, keys) {
    const promises = [];
    for (const key of keys) {
      promises.push(keyv.has(key));
    }
    return Promise.all(promises);
  }
  setTtl(ttl) {
    if (typeof ttl === "string" || ttl === void 0) {
      this._ttl = ttl;
    } else if (ttl > 0) {
      this._ttl = ttl;
    } else {
      this._ttl = void 0;
    }
  }
};
export {
  Cacheable,
  CacheableEvents,
  CacheableHooks,
  CacheableMemory,
  CacheableStats,
  Keyv2 as Keyv,
  KeyvCacheableMemory,
  KeyvHooks,
  shorthandToMilliseconds,
  shorthandToTime,
  wrap,
  wrapSync
};
