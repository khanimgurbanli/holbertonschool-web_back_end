import { KeyvStoreAdapter, StoredData, Keyv } from 'keyv';
export { Keyv, KeyvHooks, KeyvOptions, KeyvStoreAdapter } from 'keyv';
import { Hookified } from 'hookified';

type CacheableOptions$1 = {
    enabled?: boolean;
};
declare class CacheableStats {
    private _hits;
    private _misses;
    private _gets;
    private _sets;
    private _deletes;
    private _clears;
    private _vsize;
    private _ksize;
    private _count;
    private _enabled;
    constructor(options?: CacheableOptions$1);
    get enabled(): boolean;
    set enabled(enabled: boolean);
    get hits(): number;
    get misses(): number;
    get gets(): number;
    get sets(): number;
    get deletes(): number;
    get clears(): number;
    get vsize(): number;
    get ksize(): number;
    get count(): number;
    incrementHits(): void;
    incrementMisses(): void;
    incrementGets(): void;
    incrementSets(): void;
    incrementDeletes(): void;
    incrementClears(): void;
    incrementVSize(value: any): void;
    decreaseVSize(value: any): void;
    incrementKSize(key: string): void;
    decreaseKSize(key: string): void;
    incrementCount(): void;
    decreaseCount(): void;
    setCount(count: number): void;
    roughSizeOfString(value: string): number;
    roughSizeOfObject(object: any): number;
    reset(): void;
    resetStoreValues(): void;
}

type CacheableItem = {
    key: string;
    value: any;
    ttl?: number | string;
};
type CacheableStoreItem = {
    key: string;
    value: any;
    expires?: number;
};

type CacheableMemoryOptions = {
    ttl?: number | string;
    useClone?: boolean;
    lruSize?: number;
    checkInterval?: number;
};
declare class CacheableMemory {
    private readonly _hashCache;
    private readonly _hash0;
    private readonly _hash1;
    private readonly _hash2;
    private readonly _hash3;
    private readonly _hash4;
    private readonly _hash5;
    private readonly _hash6;
    private readonly _hash7;
    private readonly _hash8;
    private readonly _hash9;
    private readonly _lru;
    private _ttl;
    private _useClone;
    private _lruSize;
    private _checkInterval;
    private _interval;
    constructor(options?: CacheableMemoryOptions);
    get ttl(): number | string | undefined;
    set ttl(value: number | string | undefined);
    get useClone(): boolean;
    set useClone(value: boolean);
    get lruSize(): number;
    set lruSize(value: number);
    get checkInterval(): number;
    set checkInterval(value: number);
    get size(): number;
    get keys(): IterableIterator<string>;
    get items(): IterableIterator<CacheableStoreItem>;
    get<T>(key: string): T | undefined;
    getMany<T>(keys: string[]): T[];
    getRaw(key: string): CacheableStoreItem | undefined;
    getManyRaw(keys: string[]): Array<CacheableStoreItem | undefined>;
    set(key: string, value: any, ttl?: number | string): void;
    setMany(items: CacheableItem[]): void;
    has(key: string): boolean;
    take<T>(key: string): any;
    takeMany<T>(keys: string[]): any[];
    delete(key: string): void;
    deleteMany(keys: string[]): void;
    clear(): void;
    hashKey(key: string): number;
    getStore(key: string): Map<string, any>;
    clone(value: any): any;
    lruAddToFront(key: string): void;
    lruMoveToFront(key: string): void;
    lruResize(): void;
    checkExpiration(): void;
    startIntervalCheck(): void;
    stopIntervalCheck(): void;
    hash(object: any, algorithm?: string): string;
    wrap<T>(function_: (...arguments_: any[]) => T, options?: {
        ttl?: number;
        key?: string;
    }): (...arguments_: any[]) => T;
    private isPrimitive;
    private concatStores;
    private setTtl;
}

declare class KeyvCacheableMemory implements KeyvStoreAdapter {
    opts: CacheableMemoryOptions;
    namespace?: string | undefined;
    private readonly _cache;
    constructor(options?: CacheableMemoryOptions);
    get<Value>(key: string): Promise<StoredData<Value> | undefined>;
    getMany<Value>(keys: string[]): Promise<Array<StoredData<Value | undefined>>>;
    set(key: string, value: any, ttl?: number): Promise<void>;
    setMany(values: Array<{
        key: string;
        value: any;
        ttl?: number;
    }>): Promise<void>;
    delete(key: string): Promise<boolean>;
    deleteMany?(key: string[]): Promise<boolean>;
    clear(): Promise<void>;
    has?(key: string): Promise<boolean>;
    on(event: string, listener: (...arguments_: any[]) => void): this;
}

declare const shorthandToMilliseconds: (shorthand?: string | number) => number | undefined;
declare const shorthandToTime: (shorthand?: string | number, fromDate?: Date) => number;

type WrapOptions = {
    ttl?: number | string;
    key?: string;
    cache: Cacheable;
};
type WrapSyncOptions = {
    ttl?: number | string;
    key?: string;
    cache: CacheableMemory;
};
type AnyFunction = (...arguments_: any[]) => any;
declare function wrapSync<T>(function_: AnyFunction, options: WrapSyncOptions): AnyFunction;
declare function wrap<T>(function_: AnyFunction, options: WrapOptions): AnyFunction;

declare enum CacheableHooks {
    BEFORE_SET = "BEFORE_SET",
    AFTER_SET = "AFTER_SET",
    BEFORE_SET_MANY = "BEFORE_SET_MANY",
    AFTER_SET_MANY = "AFTER_SET_MANY",
    BEFORE_GET = "BEFORE_GET",
    AFTER_GET = "AFTER_GET",
    BEFORE_GET_MANY = "BEFORE_GET_MANY",
    AFTER_GET_MANY = "AFTER_GET_MANY"
}
declare enum CacheableEvents {
    ERROR = "error"
}
type CacheableOptions = {
    primary?: Keyv | KeyvStoreAdapter;
    secondary?: Keyv | KeyvStoreAdapter;
    stats?: boolean;
    nonBlocking?: boolean;
    ttl?: number | string;
};
declare class Cacheable extends Hookified {
    private _primary;
    private _secondary;
    private _nonBlocking;
    private _ttl?;
    private readonly _stats;
    constructor(options?: CacheableOptions);
    get stats(): CacheableStats;
    get primary(): Keyv;
    set primary(primary: Keyv);
    get secondary(): Keyv | undefined;
    set secondary(secondary: Keyv | undefined);
    get nonBlocking(): boolean;
    set nonBlocking(nonBlocking: boolean);
    get ttl(): number | string | undefined;
    set ttl(ttl: number | string | undefined);
    setPrimary(primary: Keyv | KeyvStoreAdapter): void;
    setSecondary(secondary: Keyv | KeyvStoreAdapter): void;
    get<T>(key: string): Promise<T | undefined>;
    getMany<T>(keys: string[]): Promise<Array<T | undefined>>;
    set<T>(key: string, value: T, ttl?: number | string): Promise<boolean>;
    setMany(items: CacheableItem[]): Promise<boolean>;
    take<T>(key: string): Promise<T | undefined>;
    takeMany<T>(keys: string[]): Promise<Array<T | undefined>>;
    has(key: string): Promise<boolean>;
    hasMany(keys: string[]): Promise<boolean[]>;
    delete(key: string): Promise<boolean>;
    deleteMany(keys: string[]): Promise<boolean>;
    clear(): Promise<void>;
    disconnect(): Promise<void>;
    wrap<T>(function_: (...arguments_: any[]) => T, options?: {
        ttl?: number;
        key?: string;
    }): (...arguments_: any[]) => T;
    hash(object: any, algorithm?: string): string;
    private deleteManyKeyv;
    private setManyKeyv;
    private hasManyKeyv;
    private setTtl;
}

export { Cacheable, CacheableEvents, CacheableHooks, type CacheableItem, CacheableMemory, type CacheableOptions, CacheableStats, KeyvCacheableMemory, type WrapOptions, type WrapSyncOptions, shorthandToMilliseconds, shorthandToTime, wrap, wrapSync };
